#include <GL/glut.h>
#include <iostream>
#include <cmath>

float x1u, y1u, x2u, y2u, x3u, y3u;   // Original points
float tx, ty;                         // Translation
float angleDeg;                       // Rotation angle
float sx, sy;                         // Scaling factors
int reflectionType;                   // Reflection choice
float shx, shy;                       // Shearing factors

void display() {
    glClear(GL_COLOR_BUFFER_BIT);

    // --------------------------------------------------
    // 1) ORIGINAL TRIANGLE (RED)
    // --------------------------------------------------
    glColor3f(1.0, 0.0, 0.0);
    glBegin(GL_TRIANGLES);
        glVertex2f(x1u, y1u);
        glVertex2f(x2u, y2u);
        glVertex2f(x3u, y3u);
    glEnd();


    // --------------------------------------------------
    // 2) TRANSLATED TRIANGLE (BLUE)
    // --------------------------------------------------
    glColor3f(0.0, 0.0, 1.0);
    glBegin(GL_TRIANGLES);
        glVertex2f(x1u + tx, y1u + ty);
        glVertex2f(x2u + tx, y2u + ty);
        glVertex2f(x3u + tx, y3u + ty);
    glEnd();


    // --------------------------------------------------
    // 3) ROTATED TRIANGLE (GREEN)
    // --------------------------------------------------
    float theta = angleDeg * M_PI / 180.0f;
    float cosT = std::cos(theta);
    float sinT = std::sin(theta);

    float x1r = x1u * cosT - y1u * sinT;
    float y1r = x1u * sinT + y1u * cosT;

    float x2r = x2u * cosT - y2u * sinT;
    float y2r = x2u * sinT + y2u * cosT;

    float x3r = x3u * cosT - y3u * sinT;
    float y3r = x3u * sinT + y3u * cosT;

    glColor3f(0.0, 0.7, 0.0);
    glBegin(GL_TRIANGLES);
        glVertex2f(x1r, y1r);
        glVertex2f(x2r, y2r);
        glVertex2f(x3r, y3r);
    glEnd();


    // --------------------------------------------------
    // 4) SCALED TRIANGLE (MAGENTA)
    // --------------------------------------------------
    float x1s = x1u * sx;
    float y1s = y1u * sy;

    float x2s = x2u * sx;
    float y2s = y2u * sy;

    float x3s = x3u * sx;
    float y3s = y3u * sy;

    glColor3f(1.0, 0.0, 1.0);
    glBegin(GL_TRIANGLES);
        glVertex2f(x1s, y1s);
        glVertex2f(x2s, y2s);
        glVertex2f(x3s, y3s);
    glEnd();


    // --------------------------------------------------
    // 5) REFLECTION TRIANGLE (CYAN)
    // --------------------------------------------------
    float xr1, yr1, xr2, yr2, xr3, yr3;

    switch (reflectionType) {
        case 1: // Reflect over X-axis
            xr1 = x1u;   yr1 = -y1u;
            xr2 = x2u;   yr2 = -y2u;
            xr3 = x3u;   yr3 = -y3u;
            break;

        case 2: // Reflect over Y-axis
            xr1 = -x1u;  yr1 = y1u;
            xr2 = -x2u;  yr2 = y2u;
            xr3 = -x3u;  yr3 = y3u;
            break;

        case 3: // Reflect over origin
            xr1 = -x1u;  yr1 = -y1u;
            xr2 = -x2u;  yr2 = -y2u;
            xr3 = -x3u;  yr3 = -y3u;
            break;

        case 4: // Reflect over line y = x
            xr1 = y1u;   yr1 = x1u;
            xr2 = y2u;   yr2 = x2u;
            xr3 = y3u;   yr3 = x3u;
            break;

        default:
            xr1 = xr2 = xr3 = yr1 = yr2 = yr3 = 0;
    }

    glColor3f(0.0, 1.0, 1.0); // Cyan
    glBegin(GL_TRIANGLES);
        glVertex2f(xr1, yr1);
        glVertex2f(xr2, yr2);
        glVertex2f(xr3, yr3);
    glEnd();


    // --------------------------------------------------
    // 6) SHEARED TRIANGLE (YELLOW)
    // Shear around origin:
    //   x' = x + shx * y   (X-shear)
    //   y' = y + shy * x   (Y-shear)
    // --------------------------------------------------
    float x1h = x1u + shx * y1u;
    float y1h = y1u + shy * x1u;

    float x2h = x2u + shx * y2u;
    float y2h = y2u + shy * x2u;

    float x3h = x3u + shx * y3u;
    float y3h = y3u + shy * x3u;

    glColor3f(1.0, 1.0, 0.0); // Yellow
    glBegin(GL_TRIANGLES);
        glVertex2f(x1h, y1h);
        glVertex2f(x2h, y2h);
        glVertex2f(x3h, y3h);
    glEnd();


    glFlush();
}

void init() {
    glClearColor(1.0, 1.0, 1.0, 1.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-20, 20, -20, 20);
}

int main(int argc, char** argv) {

    // ---------------- USER INPUT ----------------
    std::cout << "Enter triangle coordinates:\n";
    std::cout << "Point 1 (x y): "; std::cin >> x1u >> y1u;
    std::cout << "Point 2 (x y): "; std::cin >> x2u >> y2u;
    std::cout << "Point 3 (x y): "; std::cin >> x3u >> y3u;

    std::cout << "Enter translation Tx Ty: ";
    std::cin >> tx >> ty;

    std::cout << "Enter rotation angle (degrees): ";
    std::cin >> angleDeg;

    std::cout << "Enter scaling factors Sx Sy: ";
    std::cin >> sx >> sy;

    std::cout << "\nSelect Reflection Type:\n";
    std::cout << "1. Reflect over X-axis\n";
    std::cout << "2. Reflect over Y-axis\n";
    std::cout << "3. Reflect over Origin\n";
    std::cout << "4. Reflect over line y = x\n";
    std::cout << "Enter choice (1-4): ";
    std::cin >> reflectionType;

    std::cout << "\nEnter shearing factors shx shy (0 for none): ";
    std::cout << "\nshx (X-shear), shy (Y-shear): ";
    std::cin >> shx >> shy;

    // ---------------- GLUT INIT ----------------
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(600, 600);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("2D Transformations: T, R, S, Reflection, Shearing");

    init();
    glutDisplayFunc(display);
    glutMainLoop();

    return 0;
}
